---
layout: post
title: hashCode 메서드
date: 2023-05-02 08:39 +0900
---

### hashCode 메서드

- HashMap이나 HashSet에서 사용
- hashCode 관련 Object 명세
  1. hashCode 메서드는 동일한 객체에 대해 여러번 호출되어도 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
  2. equals 메서드를 통해 같다고 판단된 두 객체는 hashCode 메서드를 호출하면 같은 값을 반환해야 한다.
  3. equals 메서드에서 다른 객체로 판단하더라도 두 객체는 hashCode 메서드를 호출할 때 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서 다른 값을 반환할 때 해시테이블의 성능이 좋아진다.
- 논리적으로 같은 객체는 같은 해시코드 반환
- 서로 다른 인스턴스에 다른 해시코드를 반환하는 것이 좋은 해시 함수
  - 32비트 정수 범위에 균등 분배
- 구현
  1. 핵심 필드 f의 해시코드 c를 계산
  2. result = c
  3. 다른 핵심 필드 f의 해시코드 c를 계산
  4. result = 31 \* result + c
     - 31은 2^N-1의 형태 중 소수이면서 적당한 크기
  5. 모든 핵심 필드에 대해 3, 4 반복 후 result 반환
     - 파생 필드 제외 가능
     - equals에 사용되지 않은 필드 반드시 제외
  - 해시코드 계산 방법
    - 기본 타입의 경우
      - F.hashCode(f)
      - F는 f의 박싱 클래스
    - 참조 타입 & this.equals 함수에서 f.equals 사용 시
      - f.hashCode() 사용
      - 계산이 복잡할 것 같은 경우 표준형을 만들어 표준형의 hashCode 호출
      - f == null 이면 0 사용
    - 배열의 경우
      - 핵심 원소 각각을 별도 필드처럼 취급
      - 모든 원소가 핵심 원소면 Arrays.hashCode 사용
- 단위 테스트 작성
  - AutoValue 사용 시 생략 가능
- Guava의 Hashing 사용 고려
- Objects.hash 메서드
  - 코드 간결성 증대
  - 느린 속도, 성능에 민감하지 않은 상황에 사용 가능
- 해시코드 계산 비용이 큰 경우
  - 캐싱 고려
  - 인스턴스 생성 시 해시코드 계산 및 지연 초기화 고려
    - [Thread Safe](https://www.notion.so/def38a1b5b9d434f8d147fd000ccb498)하게 작성
- 핵심 필드 생략
  - 해시 품질 및 해시테이블 성능 저하
- API 명세
  - API 사용자에게 생성 규칙에 대해 자세히 공표 지양
    - 클라이언트가 값에 의지하지 않게 됨
    - 계산 방식 변경 가능
